{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Guardrails.ai Guardrails is a python package supporting: RAIL specification for defining the expected outcome to the LLM. Lightweight wrappers around LLM API calls that allow output validation and correction. Let's say you want to extract key information from a Terms-of-Service document. Here's how you can use Guardrails to get a structured, validated and corrected output from the LLM. Step 1: Add expected output schema to the RAIL spec. Start by specifying the schema and format of their desired output in an .rail file. <rail version= 0.1 > <output> <list name= \"fees\" description= \"What fees and charges are associated with my account?\" > <object> <integer name= \"index\" format= \"1-indexed\" /> <string name= \"name\" format= \"lower-case; two-words\" on-fail-lower-case= \"noop\" on-fail-two-words= \"reask\" /> <string name= \"explanation\" format= \"one-line\" on-fail-one-line= \"noop\" /> <float name= \"value\" format= \"percentage\" /> <string name= \"description\" format= \"length: 0 200\" on-fail-length= \"noop\" /> <string name= \"example\" required= \"True\" format= \"tone-twitter explain-high-quality\" /> <string name= \"advertisement\" format= \"tagline tv-ad\" /> </object> </list> <string name= 'interest_rates' description= 'What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?' format= \"one-line\" on-fail-one-line= \"noop\" /> </output> </rail> Step 2: Add the information about the high level task to the RAIL spec. Add the prompt to the .rail file. .rail supports templating, and provides helpful primitives out-of-the-box to aid in prompt construction. Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} @xml_prefix_prompt {{output_schema}} @json_suffix_prompt ... At runtime, the {{output_schema}} specification will be substituted automatically by the correct value. Anything enclosed in {} is a prompt variable which will be substituted at runtime. @xml_prefix_prompt and @json_suffix_prompt are guardrails primitives. Step 3: Wrap the LLM API call with Guardrails. Wrap any LLM API call with Guardrails to make sure that the generated output is checked, validated and corrected. import guardrails as gd import openai guard = gd . Guard . from_rail ( \"path/to/rail/file\" ) output = guard ( openai . Completion . create , document = document , temperature = 0.0 , num_tokens = 1024 ) That\u2019s it! Running this code snippet returns the following output: { 'i nterest _ra tes ' : 'Purchase A nnual Perce nta ge Ra te (APR) 0 % I ntr o APR f or t he f irs t 18 mo nt hs t ha t your Accou nt is ope n . A fter t ha t , 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . My Chase Loa n SM APR 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Bala n ce Tra nsfer APR 0 % I ntr o APR f or t he f irs t 18 mo nt hs t ha t your Accou nt is ope n . A fter t ha t , 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Cash Adva n ce APR 29.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Pe nalt y APR a n d Whe n I t Applies Up t o 29.99 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te .' ' fees ' : [ { 'i n dex' : 1 , ' na me' : 'a nnusal membership' , 'expla nat io n ' : 'a nnual membership fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 2 , ' na me' : 'my chase' , 'expla nat io n ' : ' f ixed f i nan ce charge' , 'descrip t io n ' : 'Mo nt hly fee o f 0 % o f t he amou nt o f each eligible purchase transa c t io n or amou nt selec te d t o crea te a My Chase Pla n while i n t he 0 % I ntr o Purchase APR period. A fter t ha t , mo nt hly fee o f 1.72 % o f t he amou nt o f each eligible purchase transa c t io n or amou nt selec te d t o crea te a My Chase Pla n . The My Chase Pla n Fee will be de ter mi ne d a t t he t ime each My Chase Pla n is crea te d a n d will remai n t he same u nt il t he My Chase Pla n is paid i n full .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 3 , ' na me' : 'bala n ce transfers ' , 'expla nat io n ' : 'i ntr o fee ' , 'descrip t io n ' : 'I ntr o fee o f ei t her $ 5 or 3 % o f t he amou nt o f each transfer , whichever is grea ter , o n transfers made wi t hi n 60 days o f accou nt ope n i n g. A fter t ha t : Ei t her $ 5 or 5 % o f t he amou nt o f each transfer , whichever is grea ter .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 4 , ' na me' : 'cash adva n ces' , 'expla nat io n ' : ' transa c t io n fee ' , 'descrip t io n ' : 'Ei t her $ 10 or 5 % o f t he amou nt o f each transa c t io n , whichever is grea ter .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 5 , ' na me' : ' f oreig n transa c t io ns ' , 'expla nat io n ' : ' transa c t io n fee ' , 'descrip t io n ' : ' 3 % o f t he amou nt o f each transa c t io n i n U.S. dollars.' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 6 , ' na me' : 'la te payme nt ' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'Up t o $ 40. ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 7 , ' na me' : 'over - t he' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 8 , ' na me' : 're turn payme nt ' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'Up t o $ 40. ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 9 , ' na me' : 're turn check' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' } ] }","title":"Home"},{"location":"#guardrailsai","text":"Guardrails is a python package supporting: RAIL specification for defining the expected outcome to the LLM. Lightweight wrappers around LLM API calls that allow output validation and correction. Let's say you want to extract key information from a Terms-of-Service document. Here's how you can use Guardrails to get a structured, validated and corrected output from the LLM.","title":"Guardrails.ai"},{"location":"#step-1-add-expected-output-schema-to-the-rail-spec","text":"Start by specifying the schema and format of their desired output in an .rail file. <rail version= 0.1 > <output> <list name= \"fees\" description= \"What fees and charges are associated with my account?\" > <object> <integer name= \"index\" format= \"1-indexed\" /> <string name= \"name\" format= \"lower-case; two-words\" on-fail-lower-case= \"noop\" on-fail-two-words= \"reask\" /> <string name= \"explanation\" format= \"one-line\" on-fail-one-line= \"noop\" /> <float name= \"value\" format= \"percentage\" /> <string name= \"description\" format= \"length: 0 200\" on-fail-length= \"noop\" /> <string name= \"example\" required= \"True\" format= \"tone-twitter explain-high-quality\" /> <string name= \"advertisement\" format= \"tagline tv-ad\" /> </object> </list> <string name= 'interest_rates' description= 'What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?' format= \"one-line\" on-fail-one-line= \"noop\" /> </output> </rail>","title":"Step 1: Add expected output schema to the RAIL spec."},{"location":"#step-2-add-the-information-about-the-high-level-task-to-the-rail-spec","text":"Add the prompt to the .rail file. .rail supports templating, and provides helpful primitives out-of-the-box to aid in prompt construction. Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} @xml_prefix_prompt {{output_schema}} @json_suffix_prompt ... At runtime, the {{output_schema}} specification will be substituted automatically by the correct value. Anything enclosed in {} is a prompt variable which will be substituted at runtime. @xml_prefix_prompt and @json_suffix_prompt are guardrails primitives.","title":"Step 2: Add the information about the high level task to the RAIL spec."},{"location":"#step-3-wrap-the-llm-api-call-with-guardrails","text":"Wrap any LLM API call with Guardrails to make sure that the generated output is checked, validated and corrected. import guardrails as gd import openai guard = gd . Guard . from_rail ( \"path/to/rail/file\" ) output = guard ( openai . Completion . create , document = document , temperature = 0.0 , num_tokens = 1024 ) That\u2019s it! Running this code snippet returns the following output: { 'i nterest _ra tes ' : 'Purchase A nnual Perce nta ge Ra te (APR) 0 % I ntr o APR f or t he f irs t 18 mo nt hs t ha t your Accou nt is ope n . A fter t ha t , 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . My Chase Loa n SM APR 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Bala n ce Tra nsfer APR 0 % I ntr o APR f or t he f irs t 18 mo nt hs t ha t your Accou nt is ope n . A fter t ha t , 19.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Cash Adva n ce APR 29.49 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te . Pe nalt y APR a n d Whe n I t Applies Up t o 29.99 %. This APR will vary wi t h t he marke t based o n t he Prime Ra te .' ' fees ' : [ { 'i n dex' : 1 , ' na me' : 'a nnusal membership' , 'expla nat io n ' : 'a nnual membership fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 2 , ' na me' : 'my chase' , 'expla nat io n ' : ' f ixed f i nan ce charge' , 'descrip t io n ' : 'Mo nt hly fee o f 0 % o f t he amou nt o f each eligible purchase transa c t io n or amou nt selec te d t o crea te a My Chase Pla n while i n t he 0 % I ntr o Purchase APR period. A fter t ha t , mo nt hly fee o f 1.72 % o f t he amou nt o f each eligible purchase transa c t io n or amou nt selec te d t o crea te a My Chase Pla n . The My Chase Pla n Fee will be de ter mi ne d a t t he t ime each My Chase Pla n is crea te d a n d will remai n t he same u nt il t he My Chase Pla n is paid i n full .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 3 , ' na me' : 'bala n ce transfers ' , 'expla nat io n ' : 'i ntr o fee ' , 'descrip t io n ' : 'I ntr o fee o f ei t her $ 5 or 3 % o f t he amou nt o f each transfer , whichever is grea ter , o n transfers made wi t hi n 60 days o f accou nt ope n i n g. A fter t ha t : Ei t her $ 5 or 5 % o f t he amou nt o f each transfer , whichever is grea ter .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 4 , ' na me' : 'cash adva n ces' , 'expla nat io n ' : ' transa c t io n fee ' , 'descrip t io n ' : 'Ei t her $ 10 or 5 % o f t he amou nt o f each transa c t io n , whichever is grea ter .' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 5 , ' na me' : ' f oreig n transa c t io ns ' , 'expla nat io n ' : ' transa c t io n fee ' , 'descrip t io n ' : ' 3 % o f t he amou nt o f each transa c t io n i n U.S. dollars.' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 6 , ' na me' : 'la te payme nt ' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'Up t o $ 40. ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 7 , ' na me' : 'over - t he' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 8 , ' na me' : 're turn payme nt ' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'Up t o $ 40. ' , 'adver t iseme nt ' : 'No ne ' }, { 'i n dex' : 9 , ' na me' : 're turn check' , 'expla nat io n ' : 'pe nalt y fee ' , 'descrip t io n ' : 'No ne ' , 'adver t iseme nt ' : 'No ne ' } ] }","title":"Step 3: Wrap the LLM API call with Guardrails."},{"location":"data_types/","text":"Date Bases: ScalarType Element tag: <date> Email Bases: ScalarType Element tag: <email> Float Bases: ScalarType Element tag: <float> Integer Bases: ScalarType Element tag: <integer> List Bases: NonScalarType Element tag: <list> Object Bases: NonScalarType Element tag: <object> Percentage Bases: ScalarType Element tag: <percentage> PythonCode Bases: ScalarType Element tag: <pythoncode> String Bases: ScalarType Element tag: <string> Time Bases: ScalarType Element tag: <time> URL Bases: ScalarType Element tag: <url>","title":"Data Types"},{"location":"data_types/#guardrails.datatypes.Date","text":"Bases: ScalarType Element tag: <date>","title":"Date"},{"location":"data_types/#guardrails.datatypes.Email","text":"Bases: ScalarType Element tag: <email>","title":"Email"},{"location":"data_types/#guardrails.datatypes.Float","text":"Bases: ScalarType Element tag: <float>","title":"Float"},{"location":"data_types/#guardrails.datatypes.Integer","text":"Bases: ScalarType Element tag: <integer>","title":"Integer"},{"location":"data_types/#guardrails.datatypes.List","text":"Bases: NonScalarType Element tag: <list>","title":"List"},{"location":"data_types/#guardrails.datatypes.Object","text":"Bases: NonScalarType Element tag: <object>","title":"Object"},{"location":"data_types/#guardrails.datatypes.Percentage","text":"Bases: ScalarType Element tag: <percentage>","title":"Percentage"},{"location":"data_types/#guardrails.datatypes.PythonCode","text":"Bases: ScalarType Element tag: <pythoncode>","title":"PythonCode"},{"location":"data_types/#guardrails.datatypes.String","text":"Bases: ScalarType Element tag: <string>","title":"String"},{"location":"data_types/#guardrails.datatypes.Time","text":"Bases: ScalarType Element tag: <time>","title":"Time"},{"location":"data_types/#guardrails.datatypes.URL","text":"Bases: ScalarType Element tag: <url>","title":"URL"},{"location":"getting_started/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Getting Started In this notebook, we will go through the basics of creating and RAIL spec and using Guardrails to enforce it. Objective Our goal is understand what a bank run is, and generate URL links to relevant news articles. We will first generate an RAIL spec for this and then use Guardrails to enforce it. Installation To get started, install the guardrails package with pip . ! pip install guardrails - ai Creating an RAIL spec At the heart of Guardrails is the RAIL spec. RAIL a flavor of XML (standing for **R**eliable **AI** markup **L**anguage ) that describes the expected structure and type of the output of the LLM, the quality criteria for the output to be valid and corrective actions to be taken if the output is invalid. For this task, we create an RAIL spec that requests the LLM to generate an object with 2 fields: explanation and follow_up_url . For the explanation field to be valid, the max length of the generated string should be between 200 to 280 characters in length . In case the generated string doesn't meet this criteria, for now we just want to log the validation error and continue (i.e. the noop action). For the follow_up_url field to be valid, the URL should be reachable . In case this quality criteria is not met, the generated output should be filtered out (i.e. the filter action). Ordinarily, the RAIL spec would be created in a file directly. However, for the purposes of this demo, we write the spec in a string and then create a file from it. We specify our quality criteria (generated length, URL reachability) in the format fields of the RAIL spec below. For now, we want to do nothing if the quality criteria for explanation is not met, and filter the follow_up_url if it is not valid. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"noop\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" Using Guardrails to enforce the RAIL spec We write the RAIL spec to a file and then use it to create a Guard object. The Guard object is used to wrap the LLM API call and enforce the RAIL spec on the output of the LLM call. import tempfile from rich import print import guardrails as gd with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard = gd . Guard . from_rail ( f . name ) We can see that the Guard object compiles the RAIL output specification and adds it to the provided prompt. print ( guard . base_prompt ) Explain what a bank run is in a tweet. Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <object name = \"bank_run\" format = \"length: 2\" > <string name = \"explanation\" description = \"A paragraph about what a bank run is.\" format = \"length: 200 240\" / > <url name = \"follow_up_url\" description = \"A web URL where I can read more about bank runs.\" required = \"true\" format = \"valid-url\" / > < / object > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output: Next, we call the Guard object with the LLM API call as the first argument and add any additional arguments to the LLM API call as the remaining arguments. import openai # Wrap the OpenAI API call with the `guard` object raw_llm_output , validated_output = guard ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : \"A bank run is when a large number of customers withdraw their deposits from a bank due to concerns about the bank's solvency.\" , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 125 As we can see, the explanation field didn't meet the quality criteria (length between 200 and 280 characters). However, because of the the noop action specified in the RAIL spec, the Guard object returned the output of the LLM API call as is. Next, we change the RAIL spec to reask the LLM for a correct explanation if its length is incorrect. We do this by creating a new RAIL spec and creating a new Guard object. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"reask\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard_with_reask = gd . Guard . from_rail ( f . name ) raw_llm_output , validated_output = guard_with_reask ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : 'A bank run is when a large number of people withdraw their deposits from a bank due to concerns about its solvency. This can cause a financial crisis if the bank is unable to meet the demand for withdrawals.' , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 207","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In this notebook, we will go through the basics of creating and RAIL spec and using Guardrails to enforce it.","title":"Getting Started"},{"location":"getting_started/#objective","text":"Our goal is understand what a bank run is, and generate URL links to relevant news articles. We will first generate an RAIL spec for this and then use Guardrails to enforce it.","title":"Objective"},{"location":"getting_started/#installation","text":"To get started, install the guardrails package with pip . ! pip install guardrails - ai","title":"Installation"},{"location":"getting_started/#creating-an-rail-spec","text":"At the heart of Guardrails is the RAIL spec. RAIL a flavor of XML (standing for **R**eliable **AI** markup **L**anguage ) that describes the expected structure and type of the output of the LLM, the quality criteria for the output to be valid and corrective actions to be taken if the output is invalid. For this task, we create an RAIL spec that requests the LLM to generate an object with 2 fields: explanation and follow_up_url . For the explanation field to be valid, the max length of the generated string should be between 200 to 280 characters in length . In case the generated string doesn't meet this criteria, for now we just want to log the validation error and continue (i.e. the noop action). For the follow_up_url field to be valid, the URL should be reachable . In case this quality criteria is not met, the generated output should be filtered out (i.e. the filter action). Ordinarily, the RAIL spec would be created in a file directly. However, for the purposes of this demo, we write the spec in a string and then create a file from it. We specify our quality criteria (generated length, URL reachability) in the format fields of the RAIL spec below. For now, we want to do nothing if the quality criteria for explanation is not met, and filter the follow_up_url if it is not valid. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"noop\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\"","title":"Creating an RAIL spec"},{"location":"getting_started/#using-guardrails-to-enforce-the-rail-spec","text":"We write the RAIL spec to a file and then use it to create a Guard object. The Guard object is used to wrap the LLM API call and enforce the RAIL spec on the output of the LLM call. import tempfile from rich import print import guardrails as gd with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard = gd . Guard . from_rail ( f . name ) We can see that the Guard object compiles the RAIL output specification and adds it to the provided prompt. print ( guard . base_prompt ) Explain what a bank run is in a tweet. Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <object name = \"bank_run\" format = \"length: 2\" > <string name = \"explanation\" description = \"A paragraph about what a bank run is.\" format = \"length: 200 240\" / > <url name = \"follow_up_url\" description = \"A web URL where I can read more about bank runs.\" required = \"true\" format = \"valid-url\" / > < / object > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output: Next, we call the Guard object with the LLM API call as the first argument and add any additional arguments to the LLM API call as the remaining arguments. import openai # Wrap the OpenAI API call with the `guard` object raw_llm_output , validated_output = guard ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : \"A bank run is when a large number of customers withdraw their deposits from a bank due to concerns about the bank's solvency.\" , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 125 As we can see, the explanation field didn't meet the quality criteria (length between 200 and 280 characters). However, because of the the noop action specified in the RAIL spec, the Guard object returned the output of the LLM API call as is. Next, we change the RAIL spec to reask the LLM for a correct explanation if its length is incorrect. We do this by creating a new RAIL spec and creating a new Guard object. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"reask\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard_with_reask = gd . Guard . from_rail ( f . name ) raw_llm_output , validated_output = guard_with_reask ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : 'A bank run is when a large number of people withdraw their deposits from a bank due to concerns about its solvency. This can cause a financial crisis if the bank is unable to meet the demand for withdrawals.' , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 207","title":"Using Guardrails to enforce the RAIL spec"},{"location":"validation/","text":"BugFree Validate that a value is not a bug. LowerCase Validate that a value is lower case. OneLine Validate that a value is a single line or sentence. TwoWords Validate that a value is upper case. UpperCase Validate that a value is upper case. ValidChoices ( choices , on_fail = None ) Validate that a value is within a range. Initialize the validator. ValidLength ( min = None , max = None , on_fail = None ) Validate that the length of value is within the expected range. Parameters: Name Type Description Default min int The minimum length of the value. None max int The maximum length of the value. None ValidRange ( min = None , max = None , on_fail = None ) Validate that a value is within a range. Initialize the validator. ValidUrl Validate that a value is a valid URL.","title":"Validation"},{"location":"validation/#guardrails.validators.BugFree","text":"Validate that a value is not a bug.","title":"BugFree"},{"location":"validation/#guardrails.validators.LowerCase","text":"Validate that a value is lower case.","title":"LowerCase"},{"location":"validation/#guardrails.validators.OneLine","text":"Validate that a value is a single line or sentence.","title":"OneLine"},{"location":"validation/#guardrails.validators.TwoWords","text":"Validate that a value is upper case.","title":"TwoWords"},{"location":"validation/#guardrails.validators.UpperCase","text":"Validate that a value is upper case.","title":"UpperCase"},{"location":"validation/#guardrails.validators.ValidChoices","text":"Validate that a value is within a range. Initialize the validator.","title":"ValidChoices"},{"location":"validation/#guardrails.validators.ValidLength","text":"Validate that the length of value is within the expected range. Parameters: Name Type Description Default min int The minimum length of the value. None max int The maximum length of the value. None","title":"ValidLength"},{"location":"validation/#guardrails.validators.ValidRange","text":"Validate that a value is within a range. Initialize the validator.","title":"ValidRange"},{"location":"validation/#guardrails.validators.ValidUrl","text":"Validate that a value is a valid URL.","title":"ValidUrl"},{"location":"examples/bug_free_python_code/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Generating Bug Free Leetcode Solutions Note To download this tutorial as a Jupyter notebook, click here . In this example, we want to solve String Maniuplation leetcode problems such that the code is bug free. We make the assumption that: We don't need any external libraries that are not already installed in the environment. We are able to execute the code in the environment. Objective We want to generate bug-free code for solving leetcode problems. In this example, we don't account for semantic bugs, only for syntactic bugs. In short, we want to make sure that the code can be executed without any errors. Step 1: Generating RAIL Spec Ordinarily, we could create a separate RAIL spec in a file. However, for the sake of this example, we will generate the RAIL spec in the notebook as a string. rail_str = \"\"\" <rail version=\"0.1\"> <output> <pythoncode name=\"python_code\" format=\"bug-free\" on-fail-bug-free=\"reask\" /> </output> <prompt> Given the following high level leetcode problem description, write a short Python code snippet that solves the problem. Problem Description: {{leetcode_problem}} @complete_json_suffix</prompt> </rail> \"\"\" Step 2: Create a Guard object with the RAIL Spec We create a gd.Guard object that will check, validate and correct the generated code. This object: Enforces the quality criteria specified in the RAIL spec (i.e. bug free code). Takes corrective action when the quality criteria are not met (i.e. reasking the LLM). Compiles the schema and type info from the RAIL spec and adds it to the prompt. import guardrails as gd from rich import print guard = gd . Guard . from_rail_string ( rail_str ) The Guard object compiles the output schema and adds it to the prompt. We can see the final prompt below: print ( guard . base_prompt ) Given the following high level leetcode problem description, write a short Python code snippet that solves the problem. Problem Description: { leetcode_problem } Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <pythoncode name = \"python_code\" format = \"bug-free\" / > < / output > ONLY return a valid JSON object ( no other text is necessary ) , where the key of the field in JSON is the `name` attribute of the corresponding XML, and the value is of the type specified by the corresponding XML's tag. The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. If you are unsure anywhere, enter ` None `. Here are examples of simple ( XML, JSON ) pairs that show the expected behavior: - `<string name = 'foo' format = 'two-words lower-case' / >` => ` {{ 'foo' : 'example one' }} ` - `<list name = 'bar' ><string format = 'upper-case' / >< / list >` => ` {{ \"bar\" : [ 'STRING ONE' , 'STRING TWO' , etc. ]}} ` - `<object name = 'baz' ><string name = \"foo\" format = \"capitalize two-words\" / ><integer name = \"index\" format = \"1-indexed\" / >< / object >` = > ` {{ 'baz' : {{ 'foo' : 'Some String' , 'index' : 1 }}}} ` JSON Object: Step 3: Wrap the LLM API call with Guard import openai leetcode_problem = \"\"\" Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. \"\"\" raw_llm_response , validated_response = guard ( openai . Completion . create , prompt_params = { 'leetcode_problem' : leetcode_problem }, engine = 'text-davinci-003' , max_tokens = 2048 , temperature = 0 ) Running the cell above returns: 1. The raw LLM text output as a single string. 2. A dictionary where the key is python_code and the value is the generated code. print ( validated_response ) { 'python_code' : \"def longestPalindrome(s):\\n longest_palindrome = ''\\n for i in range(len(s)):\\n for j in range(i, len(s)):\\n substring = s[i:j+1]\\n if substring == substring[::-1] and len(substring) > len(longest_palindrome):\\n longest_palindrome = substring\\n return longest_palindrome\" } Here's the generated code: print ( validated_response [ 'python_code' ]) def longestPalindrome ( s ) : longest_palindrome = '' for i in range ( len ( s )) : for j in range ( i, len ( s )) : substring = s if substring == substring [ :: -1 ] and len ( substring ) > len ( longest_palindrome ) : longest_palindrome = substring return longest_palindrome We can confirm that the code is bug free by executing the code in the environment. try : exec ( validated_response [ 'python_code' ]) print ( 'Success!' ) except Exception as e : print ( 'Failed!' ) Success!","title":"Generating bug-free Python code"},{"location":"examples/bug_free_python_code/#generating-bug-free-leetcode-solutions","text":"Note To download this tutorial as a Jupyter notebook, click here . In this example, we want to solve String Maniuplation leetcode problems such that the code is bug free. We make the assumption that: We don't need any external libraries that are not already installed in the environment. We are able to execute the code in the environment.","title":"Generating Bug Free Leetcode Solutions"},{"location":"examples/bug_free_python_code/#objective","text":"We want to generate bug-free code for solving leetcode problems. In this example, we don't account for semantic bugs, only for syntactic bugs. In short, we want to make sure that the code can be executed without any errors.","title":"Objective"},{"location":"examples/bug_free_python_code/#step-1-generating-rail-spec","text":"Ordinarily, we could create a separate RAIL spec in a file. However, for the sake of this example, we will generate the RAIL spec in the notebook as a string. rail_str = \"\"\" <rail version=\"0.1\"> <output> <pythoncode name=\"python_code\" format=\"bug-free\" on-fail-bug-free=\"reask\" /> </output> <prompt> Given the following high level leetcode problem description, write a short Python code snippet that solves the problem. Problem Description: {{leetcode_problem}} @complete_json_suffix</prompt> </rail> \"\"\"","title":"Step 1: Generating RAIL Spec"},{"location":"examples/bug_free_python_code/#step-2-create-a-guard-object-with-the-rail-spec","text":"We create a gd.Guard object that will check, validate and correct the generated code. This object: Enforces the quality criteria specified in the RAIL spec (i.e. bug free code). Takes corrective action when the quality criteria are not met (i.e. reasking the LLM). Compiles the schema and type info from the RAIL spec and adds it to the prompt. import guardrails as gd from rich import print guard = gd . Guard . from_rail_string ( rail_str ) The Guard object compiles the output schema and adds it to the prompt. We can see the final prompt below: print ( guard . base_prompt ) Given the following high level leetcode problem description, write a short Python code snippet that solves the problem. Problem Description: { leetcode_problem } Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <pythoncode name = \"python_code\" format = \"bug-free\" / > < / output > ONLY return a valid JSON object ( no other text is necessary ) , where the key of the field in JSON is the `name` attribute of the corresponding XML, and the value is of the type specified by the corresponding XML's tag. The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. If you are unsure anywhere, enter ` None `. Here are examples of simple ( XML, JSON ) pairs that show the expected behavior: - `<string name = 'foo' format = 'two-words lower-case' / >` => ` {{ 'foo' : 'example one' }} ` - `<list name = 'bar' ><string format = 'upper-case' / >< / list >` => ` {{ \"bar\" : [ 'STRING ONE' , 'STRING TWO' , etc. ]}} ` - `<object name = 'baz' ><string name = \"foo\" format = \"capitalize two-words\" / ><integer name = \"index\" format = \"1-indexed\" / >< / object >` = > ` {{ 'baz' : {{ 'foo' : 'Some String' , 'index' : 1 }}}} ` JSON Object:","title":"Step 2: Create a Guard object with the RAIL Spec"},{"location":"examples/bug_free_python_code/#step-3-wrap-the-llm-api-call-with-guard","text":"import openai leetcode_problem = \"\"\" Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. \"\"\" raw_llm_response , validated_response = guard ( openai . Completion . create , prompt_params = { 'leetcode_problem' : leetcode_problem }, engine = 'text-davinci-003' , max_tokens = 2048 , temperature = 0 ) Running the cell above returns: 1. The raw LLM text output as a single string. 2. A dictionary where the key is python_code and the value is the generated code. print ( validated_response ) { 'python_code' : \"def longestPalindrome(s):\\n longest_palindrome = ''\\n for i in range(len(s)):\\n for j in range(i, len(s)):\\n substring = s[i:j+1]\\n if substring == substring[::-1] and len(substring) > len(longest_palindrome):\\n longest_palindrome = substring\\n return longest_palindrome\" } Here's the generated code: print ( validated_response [ 'python_code' ]) def longestPalindrome ( s ) : longest_palindrome = '' for i in range ( len ( s )) : for j in range ( i, len ( s )) : substring = s if substring == substring [ :: -1 ] and len ( substring ) > len ( longest_palindrome ) : longest_palindrome = substring return longest_palindrome We can confirm that the code is bug free by executing the code in the environment. try : exec ( validated_response [ 'python_code' ]) print ( 'Success!' ) except Exception as e : print ( 'Failed!' ) Success!","title":"Step 3: Wrap the LLM API call with Guard"},{"location":"examples/extracting_entities/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Extracting entities from a Terms of Service document Note To download this example as a Jupyter notebook, click here . In this example, we will use Guardrails to extract key information from a Terms-of-Service document. To get started, download the document from here and save it as chase_card_agreement.pdf in the same directory as this notebook. Objective We want to extract structured information about all fees and interest rates associated with the Chase credit card. Step 0: Download PDF and load it as string To get started, download the document from here and save it in data/chase_card_agreement.pdf . Guardrails has some built-in functions to help with common tasks. Here, we will use the load_pdf function to load the PDF as a string. import guardrails as gd from rich import print content = gd . docs_utils . read_pdf ( 'data/chase_card_agreement.pdf' ) print ( f 'Chase Credit Card Document: \\n\\n { content [: 275 ] } \\n ...' ) Chase Credit Card Document: 2 / 25 / 23 , 7:59 PM about:blank about:blank 1 / 4 PRICING INFORMATION INTEREST RATES AND INTEREST CHARGES Purchase Annual Percentage Rate ( APR ) 0 % Intro APR for the first 18 months that your Account is open. After that, 19.49 %. This APR will vary with the market based on th ... Step 1: Create the RAIL Spec Ordinarily, we would create an RAIL spec in a separate file. For the purposes of this example, we will create the spec in this notebook as a string following the RAIL syntax. For more information on RAIL, see the RAIL documentation . Here, we request: A list of the fees associated with the card. We ask for sub-information, each with its own quality criteria and corrective action. A object (i.e. key-value pairs) for the interest. rail_str = \"\"\" <rail version=\"0.1\"> <output> <list name=\"fees\" description=\"What fees and charges are associated with my account?\"> <object> <integer name=\"index\" format=\"1-indexed\" /> <string name=\"name\" format=\"lower-case; two-words\" on-fail-lower-case=\"noop\" on-fail-two-words=\"reask\"/> <string name=\"explanation\" format=\"one-line\" on-fail-one-line=\"noop\" /> <float name=\"value\" format=\"percentage\"/> </object> </list> <object name=\"interest_rates\" description=\"What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?\" /> </output> <prompt> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {{document}} @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none</prompt> </rail> \"\"\" Step 2: Create a Guard object with the RAIL Spec We create a gd.Guard object that will check, validate and correct the output of the LLM. This object: Enforces the quality criteria specified in the RAIL spec. Takes corrective action when the quality criteria are not met. Compiles the schema and type info from the RAIL spec and adds it to the prompt. guard = gd . Guard . from_rail_string ( rail_str ) /Users/shreyarajpal/guardrails/guardrails/datatypes.py:53: UserWarning: Formatter 1-indexed is not valid for element integer. warnings.warn( /Users/shreyarajpal/guardrails/guardrails/datatypes.py:53: UserWarning: Formatter percentage is not valid for element float. warnings.warn( As we can see, a few formatters weren't supported. These formatters won't be enforced in the output, but this information can still be used to generate a prompt. We see the prompt that will be sent to the LLM. The {document} is substituted with the user provided value at runtime. print ( guard . base_prompt ) Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None' . { document } Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <list name = \"fees\" description = \"What fees and charges are associated with my account?\" > <object> <integer name = \"index\" format = \"1-indexed\" / > <string name = \"name\" format = \"lower-case; two-words\" / > <string name = \"explanation\" format = \"one-line\" / > <float name = \"value\" format = \"percentage\" / > < / object > < / list > <object name = \"interest_rates\" description = \"What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?\" / > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output: Step 3: Wrap the LLM API call with Guard import openai raw_llm_response , validated_response = guard ( openai . Completion . create , prompt_params = { 'document' : content [: 6000 ]}, engine = 'text-davinci-003' , max_tokens = 2048 , temperature = 0 ) The guard wrapper returns the raw_llm_respose (which is a simple string), and the validated and corrected output (which is a dictionary). We can see that the output is a dictionary with the correct schema and types. print ( validated_response ) { 'fees' : [ { 'index' : 1 , 'name' : 'annual membership' , 'explanation' : 'none' , 'value' : 0 } , { 'index' : 2 , 'name' : 'fee one' , 'explanation' : 'monthly fee of 0% of the amount of each eligible purchase transaction or amount selected to create a My Chase Plan while in the 0% Intro Purchase APR period. After that, monthly fee of 1.72% of the amount of each eligible purchase transaction or amount selected to create a My Chase Plan.' , 'value' : 1.72 } , { 'index' : 3 , 'name' : 'balance transfers' , 'explanation' : 'intro fee of either $5 or 3% of the amount of each transfer, whichever is greater, on transfers made within 60 days of account opening. After that: Either $5 or 5% of the amount of each transfer, whichever is greater.' , 'value' : 5 } , { 'index' : 4 , 'name' : 'cash advances' , 'explanation' : 'either $10 or 5% of the amount of each transaction, whichever is greater.' , 'value' : 5 } , { 'index' : 5 , 'name' : 'foreign transactions' , 'explanation' : '3% of the amount of each transaction in U.S. dollars.' , 'value' : 3 } , { 'index' : 6 , 'name' : 'late payment' , 'explanation' : 'up to $40.' , 'value' : 0 } , { 'index' : 7 , 'name' : 'fee two' , 'explanation' : 'none' , 'value' : 0 } , { 'index' : 8 , 'name' : 'return payment' , 'explanation' : 'up to $40.' , 'value' : 0 } , { 'index' : 9 , 'name' : 'return check' , 'explanation' : 'none' , 'value' : 0 } ] , 'interest_rates' : { 'purchase' : { 'apr' : 0 , 'explanation' : '0% Intro APR for the first 18 months that your Account is open. After that, 19.49%. This APR will vary with the market based on the Prime Rate.' } , 'my_chase_loan' : { 'apr' : 19.49 , 'explanation' : '19.49%. This APR will vary with the market based on the Prime Rate.' } , 'balance_transfer' : { 'apr' : 0 , 'explanation' : '0% Intro APR for the first 18 months that your Account is open. After that, 19.49%. This APR will vary with the market based on the Prime Rate.' } , 'cash_advance' : { 'apr' : 29.49 , 'explanation' : '29.49%. This APR will vary with the market based on the Prime Rate.' } , 'penalty' : { 'apr' : 29.99 , 'explanation' : 'Up to 29.99%. This APR will vary with the market based on the Prime Rate.' } , 'prime_rate' : 7.75 } }","title":"Extracting entities from ToS"},{"location":"examples/extracting_entities/#extracting-entities-from-a-terms-of-service-document","text":"Note To download this example as a Jupyter notebook, click here . In this example, we will use Guardrails to extract key information from a Terms-of-Service document. To get started, download the document from here and save it as chase_card_agreement.pdf in the same directory as this notebook.","title":"Extracting entities from a Terms of Service document"},{"location":"examples/extracting_entities/#objective","text":"We want to extract structured information about all fees and interest rates associated with the Chase credit card.","title":"Objective"},{"location":"examples/extracting_entities/#step-0-download-pdf-and-load-it-as-string","text":"To get started, download the document from here and save it in data/chase_card_agreement.pdf . Guardrails has some built-in functions to help with common tasks. Here, we will use the load_pdf function to load the PDF as a string. import guardrails as gd from rich import print content = gd . docs_utils . read_pdf ( 'data/chase_card_agreement.pdf' ) print ( f 'Chase Credit Card Document: \\n\\n { content [: 275 ] } \\n ...' ) Chase Credit Card Document: 2 / 25 / 23 , 7:59 PM about:blank about:blank 1 / 4 PRICING INFORMATION INTEREST RATES AND INTEREST CHARGES Purchase Annual Percentage Rate ( APR ) 0 % Intro APR for the first 18 months that your Account is open. After that, 19.49 %. This APR will vary with the market based on th ...","title":"Step 0: Download PDF and load it as string"},{"location":"examples/extracting_entities/#step-1-create-the-rail-spec","text":"Ordinarily, we would create an RAIL spec in a separate file. For the purposes of this example, we will create the spec in this notebook as a string following the RAIL syntax. For more information on RAIL, see the RAIL documentation . Here, we request: A list of the fees associated with the card. We ask for sub-information, each with its own quality criteria and corrective action. A object (i.e. key-value pairs) for the interest. rail_str = \"\"\" <rail version=\"0.1\"> <output> <list name=\"fees\" description=\"What fees and charges are associated with my account?\"> <object> <integer name=\"index\" format=\"1-indexed\" /> <string name=\"name\" format=\"lower-case; two-words\" on-fail-lower-case=\"noop\" on-fail-two-words=\"reask\"/> <string name=\"explanation\" format=\"one-line\" on-fail-one-line=\"noop\" /> <float name=\"value\" format=\"percentage\"/> </object> </list> <object name=\"interest_rates\" description=\"What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?\" /> </output> <prompt> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {{document}} @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none</prompt> </rail> \"\"\"","title":"Step 1: Create the RAIL Spec"},{"location":"examples/extracting_entities/#step-2-create-a-guard-object-with-the-rail-spec","text":"We create a gd.Guard object that will check, validate and correct the output of the LLM. This object: Enforces the quality criteria specified in the RAIL spec. Takes corrective action when the quality criteria are not met. Compiles the schema and type info from the RAIL spec and adds it to the prompt. guard = gd . Guard . from_rail_string ( rail_str ) /Users/shreyarajpal/guardrails/guardrails/datatypes.py:53: UserWarning: Formatter 1-indexed is not valid for element integer. warnings.warn( /Users/shreyarajpal/guardrails/guardrails/datatypes.py:53: UserWarning: Formatter percentage is not valid for element float. warnings.warn( As we can see, a few formatters weren't supported. These formatters won't be enforced in the output, but this information can still be used to generate a prompt. We see the prompt that will be sent to the LLM. The {document} is substituted with the user provided value at runtime. print ( guard . base_prompt ) Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None' . { document } Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <list name = \"fees\" description = \"What fees and charges are associated with my account?\" > <object> <integer name = \"index\" format = \"1-indexed\" / > <string name = \"name\" format = \"lower-case; two-words\" / > <string name = \"explanation\" format = \"one-line\" / > <float name = \"value\" format = \"percentage\" / > < / object > < / list > <object name = \"interest_rates\" description = \"What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?\" / > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output:","title":"Step 2: Create a Guard object with the RAIL Spec"},{"location":"examples/extracting_entities/#step-3-wrap-the-llm-api-call-with-guard","text":"import openai raw_llm_response , validated_response = guard ( openai . Completion . create , prompt_params = { 'document' : content [: 6000 ]}, engine = 'text-davinci-003' , max_tokens = 2048 , temperature = 0 ) The guard wrapper returns the raw_llm_respose (which is a simple string), and the validated and corrected output (which is a dictionary). We can see that the output is a dictionary with the correct schema and types. print ( validated_response ) { 'fees' : [ { 'index' : 1 , 'name' : 'annual membership' , 'explanation' : 'none' , 'value' : 0 } , { 'index' : 2 , 'name' : 'fee one' , 'explanation' : 'monthly fee of 0% of the amount of each eligible purchase transaction or amount selected to create a My Chase Plan while in the 0% Intro Purchase APR period. After that, monthly fee of 1.72% of the amount of each eligible purchase transaction or amount selected to create a My Chase Plan.' , 'value' : 1.72 } , { 'index' : 3 , 'name' : 'balance transfers' , 'explanation' : 'intro fee of either $5 or 3% of the amount of each transfer, whichever is greater, on transfers made within 60 days of account opening. After that: Either $5 or 5% of the amount of each transfer, whichever is greater.' , 'value' : 5 } , { 'index' : 4 , 'name' : 'cash advances' , 'explanation' : 'either $10 or 5% of the amount of each transaction, whichever is greater.' , 'value' : 5 } , { 'index' : 5 , 'name' : 'foreign transactions' , 'explanation' : '3% of the amount of each transaction in U.S. dollars.' , 'value' : 3 } , { 'index' : 6 , 'name' : 'late payment' , 'explanation' : 'up to $40.' , 'value' : 0 } , { 'index' : 7 , 'name' : 'fee two' , 'explanation' : 'none' , 'value' : 0 } , { 'index' : 8 , 'name' : 'return payment' , 'explanation' : 'up to $40.' , 'value' : 0 } , { 'index' : 9 , 'name' : 'return check' , 'explanation' : 'none' , 'value' : 0 } ] , 'interest_rates' : { 'purchase' : { 'apr' : 0 , 'explanation' : '0% Intro APR for the first 18 months that your Account is open. After that, 19.49%. This APR will vary with the market based on the Prime Rate.' } , 'my_chase_loan' : { 'apr' : 19.49 , 'explanation' : '19.49%. This APR will vary with the market based on the Prime Rate.' } , 'balance_transfer' : { 'apr' : 0 , 'explanation' : '0% Intro APR for the first 18 months that your Account is open. After that, 19.49%. This APR will vary with the market based on the Prime Rate.' } , 'cash_advance' : { 'apr' : 29.49 , 'explanation' : '29.49%. This APR will vary with the market based on the Prime Rate.' } , 'penalty' : { 'apr' : 29.99 , 'explanation' : 'Up to 29.99%. This APR will vary with the market based on the Prime Rate.' } , 'prime_rate' : 7.75 } }","title":"Step 3: Wrap the LLM API call with Guard"},{"location":"notebooks/getting_started/","text":"Getting Started In this notebook, we will go through the basics of creating and RAIL spec and using Guardrails to enforce it. Objective Our goal is understand what a bank run is, and generate URL links to relevant news articles. We will first generate an RAIL spec for this and then use Guardrails to enforce it. Installation To get started, install the guardrails package with pip . ! pip install guardrails - ai Creating an RAIL spec At the heart of Guardrails is the RAIL spec. RAIL a flavor of XML (standing for **R**eliable **AI** markup **L**anguage ) that describes the expected structure and type of the output of the LLM, the quality criteria for the output to be valid and corrective actions to be taken if the output is invalid. For this task, we create an RAIL spec that requests the LLM to generate an object with two fields: explanation and follow_up_url . For the explanation field to be valid, the max length of the generated string should be 280 characters. In case the generated string is between 200 to 280 characters in length . For the follow_up_url field to be valid, the URL should be reachable. In case the URL is not reachable , the LLM should be reasked to generate a valid URL. Ordinarily, the RAIL spec would be created in a file directly. However, for the purposes of this demo, we write the spec in a string and then create a file from it. We specify our quality criteria (generated length, URL reachability) in the format fields of the RAIL spec below. For now, we want to do nothing if the quality criteria for explanation is not met, and filter the follow_up_url if it is not valid. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"noop\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" Using Guardrails to enforce the RAIL spec We write the RAIL spec to a file and then use it to create a Guard object. The Guard object is used to wrap the LLM API call and enforce the RAIL spec on the output of the LLM call. import tempfile from rich import print import guardrails as gd with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard = gd . Guard . from_rail ( f . name ) We can see that the Guard object compiles the RAIL output specification and adds it to the provided prompt. print ( guard . base_prompt ) Explain what a bank run is in a tweet. Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <object name = \"bank_run\" format = \"length: 2\" > <string name = \"explanation\" description = \"A paragraph about what a bank run is.\" format = \"length: 200 240\" / > <url name = \"follow_up_url\" description = \"A web URL where I can read more about bank runs.\" required = \"true\" format = \"valid-url\" / > < / object > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output: Next, we call the Guard object with the LLM API call as the first argument and add any additional arguments to the LLM API call as the remaining arguments. import openai # Wrap the OpenAI API call with the `guard` object raw_llm_output , validated_output = guard ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : \"A bank run is when a large number of customers withdraw their deposits from a bank due to concerns about the bank's solvency.\" , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 125 As we can see, the explanation field didn't meet the quality criteria (length between 200 and 280 characters). However, because of the the noop action specified in the RAIL spec, the Guard object returned the output of the LLM API call as is. Next, we change the RAIL spec to reask the LLM for a correct explanation if its length is incorrect. We do this by creating a new RAIL spec and creating a new Guard object. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"reask\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard_with_reask = gd . Guard . from_rail ( f . name ) raw_llm_output , validated_output = guard_with_reask ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : 'A bank run is when a large number of people withdraw their deposits from a bank due to concerns about its solvency. This can cause a financial crisis if the bank is unable to meet the demand for withdrawals.' , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 207","title":"Getting Started"},{"location":"notebooks/getting_started/#getting-started","text":"In this notebook, we will go through the basics of creating and RAIL spec and using Guardrails to enforce it.","title":"Getting Started"},{"location":"notebooks/getting_started/#objective","text":"Our goal is understand what a bank run is, and generate URL links to relevant news articles. We will first generate an RAIL spec for this and then use Guardrails to enforce it.","title":"Objective"},{"location":"notebooks/getting_started/#installation","text":"To get started, install the guardrails package with pip . ! pip install guardrails - ai","title":"Installation"},{"location":"notebooks/getting_started/#creating-an-rail-spec","text":"At the heart of Guardrails is the RAIL spec. RAIL a flavor of XML (standing for **R**eliable **AI** markup **L**anguage ) that describes the expected structure and type of the output of the LLM, the quality criteria for the output to be valid and corrective actions to be taken if the output is invalid. For this task, we create an RAIL spec that requests the LLM to generate an object with two fields: explanation and follow_up_url . For the explanation field to be valid, the max length of the generated string should be 280 characters. In case the generated string is between 200 to 280 characters in length . For the follow_up_url field to be valid, the URL should be reachable. In case the URL is not reachable , the LLM should be reasked to generate a valid URL. Ordinarily, the RAIL spec would be created in a file directly. However, for the purposes of this demo, we write the spec in a string and then create a file from it. We specify our quality criteria (generated length, URL reachability) in the format fields of the RAIL spec below. For now, we want to do nothing if the quality criteria for explanation is not met, and filter the follow_up_url if it is not valid. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"noop\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\"","title":"Creating an RAIL spec"},{"location":"notebooks/getting_started/#using-guardrails-to-enforce-the-rail-spec","text":"We write the RAIL spec to a file and then use it to create a Guard object. The Guard object is used to wrap the LLM API call and enforce the RAIL spec on the output of the LLM call. import tempfile from rich import print import guardrails as gd with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard = gd . Guard . from_rail ( f . name ) We can see that the Guard object compiles the RAIL output specification and adds it to the provided prompt. print ( guard . base_prompt ) Explain what a bank run is in a tweet. Given below is XML that describes the information to extract from this document and the tags to extract it into. < output > <object name = \"bank_run\" format = \"length: 2\" > <string name = \"explanation\" description = \"A paragraph about what a bank run is.\" format = \"length: 200 240\" / > <url name = \"follow_up_url\" description = \"A web URL where I can read more about bank runs.\" required = \"true\" format = \"valid-url\" / > < / object > < / output > ONLY return a valid JSON object ( no other text is necessary ) . The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. JSON Output: Next, we call the Guard object with the LLM API call as the first argument and add any additional arguments to the LLM API call as the remaining arguments. import openai # Wrap the OpenAI API call with the `guard` object raw_llm_output , validated_output = guard ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : \"A bank run is when a large number of customers withdraw their deposits from a bank due to concerns about the bank's solvency.\" , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 125 As we can see, the explanation field didn't meet the quality criteria (length between 200 and 280 characters). However, because of the the noop action specified in the RAIL spec, the Guard object returned the output of the LLM API call as is. Next, we change the RAIL spec to reask the LLM for a correct explanation if its length is incorrect. We do this by creating a new RAIL spec and creating a new Guard object. rail_spec = \"\"\" <rail version=\"0.1\"> <output> <object name=\"bank_run\" format=\"length: 2\"> <string name=\"explanation\" description=\"A paragraph about what a bank run is.\" format=\"length: 200 240\" on-fail-length=\"reask\" /> <url name=\"follow_up_url\" description=\"A web URL where I can read more about bank runs.\" required=\"true\" format=\"valid-url\" on-fail-valid-url=\"filter\" /> </object> </output> <prompt> Explain what a bank run is in a tweet. @xml_prefix_prompt {output_schema} @json_suffix_prompt_v2_wo_none </prompt> </rail> \"\"\" with tempfile . NamedTemporaryFile ( mode = \"w\" , suffix = \".rail\" ) as f : f . write ( rail_spec ) f . flush () guard_with_reask = gd . Guard . from_rail ( f . name ) raw_llm_output , validated_output = guard_with_reask ( openai . Completion . create , engine = \"text-davinci-003\" , max_tokens = 1024 , temperature = 0.3 ) # Print the validated output from the LLM print ( validated_output ) { 'bank_run' : { 'explanation' : 'A bank run is when a large number of people withdraw their deposits from a bank due to concerns about its solvency. This can cause a financial crisis if the bank is unable to meet the demand for withdrawals.' , 'follow_up_url' : 'https://www.investopedia.com/terms/b/bankrun.asp' } } print ( f 'Len of explanation: { len ( validated_output [ \"bank_run\" ][ \"explanation\" ]) } ' ) Len of explanation: 207","title":"Using Guardrails to enforce the RAIL spec"},{"location":"rail/","text":"Overview \ud83e\udd16 What is RAIL ? .RAIL is a dialect of XML. It stands for **R**eliable **AI** markup **L**anguage , and it can be used to define: The structure of the expected outcome of the LLM. (E.g. JSON) The type of each field in the expected outcome. (E.g. string, integer, list, object) The quality criteria for the expected outcome to be considered valid. (E.g. generated text should be bias-free, generated code should be bug-free) The corrective action to take in case the quality criteria is not met. (E.g. reask the question, filter the LLM, progrmatically fix, etc.) Expand to see an example of an RAIL specification. <rail version= \"0.1\" > <output> <list name= \"fees\" description= \"What fees and charges are associated with my account?\" > <object> <integer name= \"index\" format= \"1-indexed\" /> <string name= \"name\" format= \"lower-case; two-words\" on-fail-lower-case= \"noop\" on-fail-two-words= \"reask\" /> <string name= \"explanation\" format= \"one-line\" on-fail-one-line= \"noop\" /> <float name= \"value\" format= \"percentage\" /> </object> </list> <string name= 'interest_rates' description= 'What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?' format= \"one-line\" on-fail-one-line= \"noop\" /> </output> <prompt> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} @xml_prefix_prompt {{output_schema}} @json_suffix_prompt </prompt> <script language= 'python' > from guardrails.validators import Validator, EventDetail, register_validator import random @register_validator(name=\"custom\", data_type=\"any\") class CustomValidator(Validator): def __init__(self, *args, **kwargs): super(CustomValidator, self).__init__(*args, **kwargs) def validate(self, key: str, value: Any, schema: Union[Dict, List]): \"\"\"Validate that a value is within a range.\"\"\" logger.debug(f\"Validating {value} is in choices {self._choices}...\") if random.random() > 0.5: raise EventDetail( key, value, schema, f\"Value {value} is not in choices {self._choices}.\", None, ) return schema </script> </rail> \ud83e\udd14 Why RAIL ? Language agnostic: RAIL Specifications can be enforced in any language. Simple and familiar: RAIL should be familiar to anyone familiar with HTML, and should be easy to learn. Validation and correction : RAIL can be used to define quality criteria for the expected output, and corrective actions to take in case the quality criteria is not met. Can define complex structures: RAIL can be used to define arbitrarily complex structures, such as nested lists, nested objects, etc. Supports writing custom code: If needed, RAIL supports writing code for using validators, custom corrective actions, etc. Design inspiration HTML, CSS and Javascript: RAIL spec is a dialect of XML, and so is similar to HTML. Specifying quality criteria is done via the format attribute, which is similar to CSS style tags. Corrective actions are specified via the on-fail-* attributes, which is similar to Javascript event handlers. OpenAPI as an open standard for creating machine-readable RESTful APIs. \ud83d\udcda Components of an RAIL Specification The RAIL specification contains 3 main components: Output : Contains information about the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. This is the main component of the RAIL specification, which enforces the guarantees that the LLM should provide. Check out the RAIL Output page for more details, including the full specifcation of how to create complex output schemas. Prompt : Prompt template, and contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details. (Experimental) (Optional) Script : Contains any custom code for implementing the schema. This is useful for implementing custom validators, custom corrective actions, etc. Check out the RAIL Script page for more details. Let's see an example of an RAIL specification in action: <rail version= \"0.1\" > <output> <!-- (1)! --> ... </output> <prompt> <!-- (2)! --> ... </prompt> <script language= python > <!-- (3)! --> ... </script> </rail> The output element contains the structure of the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. The prompt element contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details. The script element is optional, and contains any custom code for implementing the schema. \ud83d\udcd6 How to use RAIL in Guardrails? After creating an RAIL specification, you can use to get corrected output from LLMs by wrapping your LLM API call with a Guard module. Here's an example of doing that: import guardrails as gd # Create a Guard object guard = gd . Guard . from_rail ( 'path/to/rail/spec.xml' ) # (1)! validated_output = guard ( openai . Completion . create , # (2)! ** prompt_args , * args , ** kwargs ) A Guard object is created from an RAIL specification. This object manages the validation and correction of the output of the LLM, as well as the prompt that is sent to the LLM. Wrap the LLM API call ( openai.Completion.create ) with the Guard object, and add any additional arguments that you want to pass to the LLM API call. Instead of returning the raw text object, the Guard object will return a JSON object that is validated and corrected according to the RAIL specification.","title":"Overview"},{"location":"rail/#overview","text":"","title":"Overview"},{"location":"rail/#what-is-rail","text":".RAIL is a dialect of XML. It stands for **R**eliable **AI** markup **L**anguage , and it can be used to define: The structure of the expected outcome of the LLM. (E.g. JSON) The type of each field in the expected outcome. (E.g. string, integer, list, object) The quality criteria for the expected outcome to be considered valid. (E.g. generated text should be bias-free, generated code should be bug-free) The corrective action to take in case the quality criteria is not met. (E.g. reask the question, filter the LLM, progrmatically fix, etc.) Expand to see an example of an RAIL specification. <rail version= \"0.1\" > <output> <list name= \"fees\" description= \"What fees and charges are associated with my account?\" > <object> <integer name= \"index\" format= \"1-indexed\" /> <string name= \"name\" format= \"lower-case; two-words\" on-fail-lower-case= \"noop\" on-fail-two-words= \"reask\" /> <string name= \"explanation\" format= \"one-line\" on-fail-one-line= \"noop\" /> <float name= \"value\" format= \"percentage\" /> </object> </list> <string name= 'interest_rates' description= 'What are the interest rates offered by the bank on savings and checking accounts, loans, and credit products?' format= \"one-line\" on-fail-one-line= \"noop\" /> </output> <prompt> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} @xml_prefix_prompt {{output_schema}} @json_suffix_prompt </prompt> <script language= 'python' > from guardrails.validators import Validator, EventDetail, register_validator import random @register_validator(name=\"custom\", data_type=\"any\") class CustomValidator(Validator): def __init__(self, *args, **kwargs): super(CustomValidator, self).__init__(*args, **kwargs) def validate(self, key: str, value: Any, schema: Union[Dict, List]): \"\"\"Validate that a value is within a range.\"\"\" logger.debug(f\"Validating {value} is in choices {self._choices}...\") if random.random() > 0.5: raise EventDetail( key, value, schema, f\"Value {value} is not in choices {self._choices}.\", None, ) return schema </script> </rail>","title":"\ud83e\udd16 What is RAIL?"},{"location":"rail/#why-rail","text":"Language agnostic: RAIL Specifications can be enforced in any language. Simple and familiar: RAIL should be familiar to anyone familiar with HTML, and should be easy to learn. Validation and correction : RAIL can be used to define quality criteria for the expected output, and corrective actions to take in case the quality criteria is not met. Can define complex structures: RAIL can be used to define arbitrarily complex structures, such as nested lists, nested objects, etc. Supports writing custom code: If needed, RAIL supports writing code for using validators, custom corrective actions, etc. Design inspiration HTML, CSS and Javascript: RAIL spec is a dialect of XML, and so is similar to HTML. Specifying quality criteria is done via the format attribute, which is similar to CSS style tags. Corrective actions are specified via the on-fail-* attributes, which is similar to Javascript event handlers. OpenAPI as an open standard for creating machine-readable RESTful APIs.","title":"\ud83e\udd14 Why RAIL?"},{"location":"rail/#components-of-an-rail-specification","text":"The RAIL specification contains 3 main components: Output : Contains information about the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. This is the main component of the RAIL specification, which enforces the guarantees that the LLM should provide. Check out the RAIL Output page for more details, including the full specifcation of how to create complex output schemas. Prompt : Prompt template, and contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details. (Experimental) (Optional) Script : Contains any custom code for implementing the schema. This is useful for implementing custom validators, custom corrective actions, etc. Check out the RAIL Script page for more details. Let's see an example of an RAIL specification in action: <rail version= \"0.1\" > <output> <!-- (1)! --> ... </output> <prompt> <!-- (2)! --> ... </prompt> <script language= python > <!-- (3)! --> ... </script> </rail> The output element contains the structure of the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. The prompt element contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details. The script element is optional, and contains any custom code for implementing the schema.","title":"\ud83d\udcda Components of an RAIL Specification"},{"location":"rail/#how-to-use-rail-in-guardrails","text":"After creating an RAIL specification, you can use to get corrected output from LLMs by wrapping your LLM API call with a Guard module. Here's an example of doing that: import guardrails as gd # Create a Guard object guard = gd . Guard . from_rail ( 'path/to/rail/spec.xml' ) # (1)! validated_output = guard ( openai . Completion . create , # (2)! ** prompt_args , * args , ** kwargs ) A Guard object is created from an RAIL specification. This object manages the validation and correction of the output of the LLM, as well as the prompt that is sent to the LLM. Wrap the LLM API call ( openai.Completion.create ) with the Guard object, and add any additional arguments that you want to pass to the LLM API call. Instead of returning the raw text object, the Guard object will return a JSON object that is validated and corrected according to the RAIL specification.","title":"\ud83d\udcd6 How to use RAIL in Guardrails?"},{"location":"rail/output/","text":"Output Element The <output>...</output> element of an RAIL spec is used to give precise specification of the expected output of the LLM. It specifies the structure of the expected output (e.g. JSON), the type of each field, the quality criteria for each field to be considered valid (e.g. generated text should be bias-free, generated code should be bug-free), and the corrective action to take in case the quality criteria is not met (e.g. reask the question to the LLM, filter offending values, progrmatically fix, etc.) Example: RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words\" on-fail-two-words= \"reask\" /> <float name= \"score\" description= \"The score of the generated text\" format= \"min-val: 0\" on-fail-min-val= \"fix\" /> <object name= \"metadata\" description= \"The metadata associated with the generated text\" > <string name= \"key_1\" description= \"description of key_1\" /> ... </object> </output> </rail> { \"text\" : \"string output\" , \"score\" : 0.0 , \"metadata\" : { \"key_1\" : \"string\" , ... } } \ud83c\udff7\ufe0f RAIL Elements At the heart of the RAIL specification is the use of elements. Each element's tag represents a type of data. For example, in the element <string ... /> , the tag represents a string, the <integer ... /> elements represents an integer, the <object ...></object> element represents an object, etc. Note The tag of RAIL element is the same as the \"type\" of the data it represents. E.g. <string .../> element will generate a string, <integer .../> element will generate an integer, etc. Supported types Guardrails supports many data types, including:, string , integer , float , boolean , list , object , url , email and many more. Check out the RAIL Data Types page for a list of supported data types. Scalar vs Non-scalar types Guardrails supports two types of data types: scalar and non-scalar. Scalar Non Scalar Scalar types are void elements, and can't have any child elements. Non-scalar types can be non-void, and can have closing tags and child elements. Syntax: <string ... /> Syntax: Examples: string , integer , float , boolean , url , email , etc. Examples: list and object are the only non-scalar types supported by Guardrails. Supported attributes Each element can have attributes that specify additional information about the data, such as: name attribute that specifies the name of the field. This will be the key in the output JSON. E.g. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" /> </output> </rail> { \"some_key\" : \"...\" } description attribute that specifies the description of the field. This is similar to a prompt that will be provided to the LLM. It can contain more context to help the LLM generate the correct output. (Coming soon!) required attribute that specifies whether the field is required or not. If the field is required, the LLM will be asked to generate the field until it is generated correctly. If the field is not required, the LLM will not be asked to generate the field if it is not generated correctly. format attribute that specifies the quality criteria that the field should respect. The format attribute can contain multiple quality criteria separated by a colon ( ; ). For example, two-words; upper-case . on-fail-{quality-criteria} attribute that specifies the corrective action to take in case the quality criteria is not met. For example, on-fail-two-words=\"reask\" specifies that if the field does not have two words, the LLM should be asked to re-generate the field. E.g., RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" description= \"Detailed description of what the value of the key should be\" required= \"true\" format= \"two-words; upper-case\" on-fail-two-words= \"reask\" on-fail-upper-case= \"noop\" /> </output> </rail> { \"some_key\" : \"SOME STRING\" } \ud83e\ude9c Specifying output structure You can combine RAIL elements to create an arbitrarily complex output structure. Flat JSON output RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" .... /> <integer name= \"some_other_key\" .... /> </output> </rail> { \"some_key\" : \"string\" , \"some_other_key\" : 0 } JSON output with objects object elements can be used to specify a JSON object, which is a collection of key-value pairs. A child of an object element represents a key in the JSON object. The child element can be any RAIL element, including another list or object elements. The value of the key is generated by the LLM based on the info provided by the child element. An object element can have multiple children, each of which can be any RAIL element, including another list or object elements. Formatters can be applied to the child elements of an object element. For example, if the child element is a string element, the format attribute can be used to specify the quality criteria for the strings in the list. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <object name= \"some_object\" > <string name= \"some_str_key\" description= \"What should the value for this key represent?\" format= \"two-words; upper-case\" /> <integer name= \"some_other_key\" description= \"What should this integer represent?\" format= \"min-val: 0\" /> </object> </output> </rail> { \"some_object\" : { \"some_str_key\" : \"SOME STRING\" , \"some_other_key\" : 0 } } In the above example, \"SOME STRING\" is the value for the some_str_key key, and is generated based on the name, description and quality criteria provided by the <string name=\"some_str_key\" ... /> element. Note The object element doesn't need to have children. If child elements are not provided, the LLM will automatically generate keys and values for the object based on the name , description and format attributes of the object element. Providing child elements is useful when you want to specify the keys and values that the LLM should generate. JSON output with lists list elements can be used to specify a list of values. Currently, a list element can only contain a single child element. This means that a list can only contain a single type of data. For example, a list can only contain strings, or a list can only contain integers, but a list cannot contain both strings and integers. This child element can be any RAIL element, including another list or object elements. The child of a list element doesn't need to have a name attribute, since items in a list don't have names. Formatters can be applied to the child element of a list element. For example, if the child element is a string element, the format attribute can be used to specify the quality criteria for the strings in the list. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <list name= \"some_list\" format= \"min-len: 2\" > <string format= \"two-words; upper-case\" /> </list> </output> </rail> { \"some_list\" : [ \"STRING 1\" , \"STRING 2\" ] } Note The list element doesn't need to have a child element. If a child element is not provided, the LLM will automatically generate values for the list based on the name , description and format attributes of the list element. Providing a child element is useful when you want to have more control over the values that the LLM should generate. \ud83c\udf40 Specifying quality criteria The format attribute allows specifying the quality criteria for each field in the expected output. The format attribute can contain multiple quality criteria separated by a colon ( ; ). For example, <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words; upper-case\" on-fail-two-words= \"reask\" /> </output> </rail> The above example specifies that the text field should be a string with two words and the text should be returned in upper case. Quality criteria under the hood Under the hood, the format attribute is parsed into a list of quality criteria. Each quality criteria is backed by a Validator class that checks if the generated output meets the quality criteria. For example, the two-words quality criteria is backed by the TwoWords class, which checks if the generated output has two words. Each quality criteria is then checked against the generated output. If the quality criteria is not met, the corrective action specified by the on-fail-{quality-criteria} attribute is taken. Supported criteria Each quality critera is relevant to a specific data type. For example, the two-words quality criteria is only relevant to strings, and the positive quality criteria is only relevant to integers and floats. To see the full list of supported quality criteria, check out the Validation page. \ud83d\udee0\ufe0f Specifying corrective actions The on-fail-{quality-criteria} attribute allows specifying the corrective action that should be taken if the quality criteria is not met. The corrective action can be one of the following: Action Behavior reask Reask the LLM to generate an output that meets the quality criteria. The prompt used for reasking contains information about which quality criteria failed, which is autp-generated by the validator. fix Programmatically fix the generated output to meet the quality criteria. E.g. for the formatter two-words , the programatic fix simply takes the first 2 words of the generated string. filter Filter the incorrect value. This only filters the field that fails, and will return the rest of the generated output. refrain Refrain from returning an output. If a formatter has the corrective action refrain, then on failure there will be a None output returned instead of the JSON. noop Do nothing. The failure will still be recorded in the logs, but no corrective action will be taken. \ud83d\ude92 Adding compiled output element to prompt In order to generate the correct LLM output, the output schema needs to be compiled and added to the prompt. This is handled automatically by the Guardrails library. The output element can be compiled into different formats to be used in the prompt. Currently, only a passthrough compilation into XML is supported, but in the future we will support additional compilation formats like TypeScript . Passthrough ( XML ) compilation By default, the output element will be compiled into XML and added to the prompt. Compilation into XML involves removing any on-fail-{quality-criteria} attributes, and adding the output element to the prompt. An example of the compiled output element: RAIL Spec Compiled XML added to prompt <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words; upper-case\" /> </output> </rail> <output> <string name= \"text\" description= \"The generated text\" /> </output> TypeScript Compilation Coming soon! \u2753 Unsupported tags and attributes By default, Guardrails will not throw an error if you add an unsupported type, attribute or quality criteria. Instead, it will treat the unsupported type as a string, and will not perform any quality checks on the field. Often, LLMs will generate a string for an unsupported type, so this behavior is useful. Unsupported tags and attributes will still be included in the output schema definition that is appended to the prompt. This behavior can be changed by setting the strict attribute of the <output> element to true . If strict is set to true , Guardrails will throw an error if you add an unsupported type, attribute or quality criteria. <rail version= \"0.1\" > <output strict= \"true\" > <unsupported-type ... /> </output> </rail> This will throw an error: \u274c Error: Unsupported type: unsupported-type","title":"Output Element"},{"location":"rail/output/#output-element","text":"The <output>...</output> element of an RAIL spec is used to give precise specification of the expected output of the LLM. It specifies the structure of the expected output (e.g. JSON), the type of each field, the quality criteria for each field to be considered valid (e.g. generated text should be bias-free, generated code should be bug-free), and the corrective action to take in case the quality criteria is not met (e.g. reask the question to the LLM, filter offending values, progrmatically fix, etc.) Example: RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words\" on-fail-two-words= \"reask\" /> <float name= \"score\" description= \"The score of the generated text\" format= \"min-val: 0\" on-fail-min-val= \"fix\" /> <object name= \"metadata\" description= \"The metadata associated with the generated text\" > <string name= \"key_1\" description= \"description of key_1\" /> ... </object> </output> </rail> { \"text\" : \"string output\" , \"score\" : 0.0 , \"metadata\" : { \"key_1\" : \"string\" , ... } }","title":"Output Element"},{"location":"rail/output/#rail-elements","text":"At the heart of the RAIL specification is the use of elements. Each element's tag represents a type of data. For example, in the element <string ... /> , the tag represents a string, the <integer ... /> elements represents an integer, the <object ...></object> element represents an object, etc. Note The tag of RAIL element is the same as the \"type\" of the data it represents. E.g. <string .../> element will generate a string, <integer .../> element will generate an integer, etc.","title":"\ud83c\udff7\ufe0f RAIL Elements"},{"location":"rail/output/#supported-types","text":"Guardrails supports many data types, including:, string , integer , float , boolean , list , object , url , email and many more. Check out the RAIL Data Types page for a list of supported data types.","title":"Supported types"},{"location":"rail/output/#scalar-vs-non-scalar-types","text":"Guardrails supports two types of data types: scalar and non-scalar. Scalar Non Scalar Scalar types are void elements, and can't have any child elements. Non-scalar types can be non-void, and can have closing tags and child elements. Syntax: <string ... /> Syntax: Examples: string , integer , float , boolean , url , email , etc. Examples: list and object are the only non-scalar types supported by Guardrails.","title":"Scalar vs Non-scalar types"},{"location":"rail/output/#supported-attributes","text":"Each element can have attributes that specify additional information about the data, such as: name attribute that specifies the name of the field. This will be the key in the output JSON. E.g. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" /> </output> </rail> { \"some_key\" : \"...\" } description attribute that specifies the description of the field. This is similar to a prompt that will be provided to the LLM. It can contain more context to help the LLM generate the correct output. (Coming soon!) required attribute that specifies whether the field is required or not. If the field is required, the LLM will be asked to generate the field until it is generated correctly. If the field is not required, the LLM will not be asked to generate the field if it is not generated correctly. format attribute that specifies the quality criteria that the field should respect. The format attribute can contain multiple quality criteria separated by a colon ( ; ). For example, two-words; upper-case . on-fail-{quality-criteria} attribute that specifies the corrective action to take in case the quality criteria is not met. For example, on-fail-two-words=\"reask\" specifies that if the field does not have two words, the LLM should be asked to re-generate the field. E.g., RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" description= \"Detailed description of what the value of the key should be\" required= \"true\" format= \"two-words; upper-case\" on-fail-two-words= \"reask\" on-fail-upper-case= \"noop\" /> </output> </rail> { \"some_key\" : \"SOME STRING\" }","title":"Supported attributes"},{"location":"rail/output/#specifying-output-structure","text":"You can combine RAIL elements to create an arbitrarily complex output structure.","title":"\ud83e\ude9c Specifying output structure"},{"location":"rail/output/#flat-json-output","text":"RAIL Spec Output JSON <rail version= \"0.1\" > <output> <string name= \"some_key\" .... /> <integer name= \"some_other_key\" .... /> </output> </rail> { \"some_key\" : \"string\" , \"some_other_key\" : 0 }","title":"Flat JSON output"},{"location":"rail/output/#json-output-with-objects","text":"object elements can be used to specify a JSON object, which is a collection of key-value pairs. A child of an object element represents a key in the JSON object. The child element can be any RAIL element, including another list or object elements. The value of the key is generated by the LLM based on the info provided by the child element. An object element can have multiple children, each of which can be any RAIL element, including another list or object elements. Formatters can be applied to the child elements of an object element. For example, if the child element is a string element, the format attribute can be used to specify the quality criteria for the strings in the list. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <object name= \"some_object\" > <string name= \"some_str_key\" description= \"What should the value for this key represent?\" format= \"two-words; upper-case\" /> <integer name= \"some_other_key\" description= \"What should this integer represent?\" format= \"min-val: 0\" /> </object> </output> </rail> { \"some_object\" : { \"some_str_key\" : \"SOME STRING\" , \"some_other_key\" : 0 } } In the above example, \"SOME STRING\" is the value for the some_str_key key, and is generated based on the name, description and quality criteria provided by the <string name=\"some_str_key\" ... /> element. Note The object element doesn't need to have children. If child elements are not provided, the LLM will automatically generate keys and values for the object based on the name , description and format attributes of the object element. Providing child elements is useful when you want to specify the keys and values that the LLM should generate.","title":"JSON output with objects"},{"location":"rail/output/#json-output-with-lists","text":"list elements can be used to specify a list of values. Currently, a list element can only contain a single child element. This means that a list can only contain a single type of data. For example, a list can only contain strings, or a list can only contain integers, but a list cannot contain both strings and integers. This child element can be any RAIL element, including another list or object elements. The child of a list element doesn't need to have a name attribute, since items in a list don't have names. Formatters can be applied to the child element of a list element. For example, if the child element is a string element, the format attribute can be used to specify the quality criteria for the strings in the list. RAIL Spec Output JSON <rail version= \"0.1\" > <output> <list name= \"some_list\" format= \"min-len: 2\" > <string format= \"two-words; upper-case\" /> </list> </output> </rail> { \"some_list\" : [ \"STRING 1\" , \"STRING 2\" ] } Note The list element doesn't need to have a child element. If a child element is not provided, the LLM will automatically generate values for the list based on the name , description and format attributes of the list element. Providing a child element is useful when you want to have more control over the values that the LLM should generate.","title":"JSON output with lists"},{"location":"rail/output/#specifying-quality-criteria","text":"The format attribute allows specifying the quality criteria for each field in the expected output. The format attribute can contain multiple quality criteria separated by a colon ( ; ). For example, <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words; upper-case\" on-fail-two-words= \"reask\" /> </output> </rail> The above example specifies that the text field should be a string with two words and the text should be returned in upper case.","title":"\ud83c\udf40 Specifying quality criteria"},{"location":"rail/output/#quality-criteria-under-the-hood","text":"Under the hood, the format attribute is parsed into a list of quality criteria. Each quality criteria is backed by a Validator class that checks if the generated output meets the quality criteria. For example, the two-words quality criteria is backed by the TwoWords class, which checks if the generated output has two words. Each quality criteria is then checked against the generated output. If the quality criteria is not met, the corrective action specified by the on-fail-{quality-criteria} attribute is taken.","title":"Quality criteria under the hood"},{"location":"rail/output/#supported-criteria","text":"Each quality critera is relevant to a specific data type. For example, the two-words quality criteria is only relevant to strings, and the positive quality criteria is only relevant to integers and floats. To see the full list of supported quality criteria, check out the Validation page.","title":"Supported criteria"},{"location":"rail/output/#specifying-corrective-actions","text":"The on-fail-{quality-criteria} attribute allows specifying the corrective action that should be taken if the quality criteria is not met. The corrective action can be one of the following: Action Behavior reask Reask the LLM to generate an output that meets the quality criteria. The prompt used for reasking contains information about which quality criteria failed, which is autp-generated by the validator. fix Programmatically fix the generated output to meet the quality criteria. E.g. for the formatter two-words , the programatic fix simply takes the first 2 words of the generated string. filter Filter the incorrect value. This only filters the field that fails, and will return the rest of the generated output. refrain Refrain from returning an output. If a formatter has the corrective action refrain, then on failure there will be a None output returned instead of the JSON. noop Do nothing. The failure will still be recorded in the logs, but no corrective action will be taken.","title":"\ud83d\udee0\ufe0f Specifying corrective actions"},{"location":"rail/output/#adding-compiled-output-element-to-prompt","text":"In order to generate the correct LLM output, the output schema needs to be compiled and added to the prompt. This is handled automatically by the Guardrails library. The output element can be compiled into different formats to be used in the prompt. Currently, only a passthrough compilation into XML is supported, but in the future we will support additional compilation formats like TypeScript .","title":"\ud83d\ude92 Adding compiled output element to prompt"},{"location":"rail/output/#passthrough-xml-compilation","text":"By default, the output element will be compiled into XML and added to the prompt. Compilation into XML involves removing any on-fail-{quality-criteria} attributes, and adding the output element to the prompt. An example of the compiled output element: RAIL Spec Compiled XML added to prompt <rail version= \"0.1\" > <output> <string name= \"text\" description= \"The generated text\" format= \"two-words; upper-case\" /> </output> </rail> <output> <string name= \"text\" description= \"The generated text\" /> </output>","title":"Passthrough (XML) compilation"},{"location":"rail/output/#typescript-compilation","text":"Coming soon!","title":"TypeScript Compilation"},{"location":"rail/output/#unsupported-tags-and-attributes","text":"By default, Guardrails will not throw an error if you add an unsupported type, attribute or quality criteria. Instead, it will treat the unsupported type as a string, and will not perform any quality checks on the field. Often, LLMs will generate a string for an unsupported type, so this behavior is useful. Unsupported tags and attributes will still be included in the output schema definition that is appended to the prompt. This behavior can be changed by setting the strict attribute of the <output> element to true . If strict is set to true , Guardrails will throw an error if you add an unsupported type, attribute or quality criteria. <rail version= \"0.1\" > <output strict= \"true\" > <unsupported-type ... /> </output> </rail> This will throw an error: \u274c Error: Unsupported type: unsupported-type","title":"\u2753 Unsupported tags and attributes"},{"location":"rail/prompt/","text":"Prompt Element The <prompt></prompt> element contains the high level instructions sent to the LLM, that describe the high level task. \ud83d\udcda Components of a Prompt In addition to the high level task description, the prompt also contains the following: Component Syntax Description Variables {{variable_name}} These are provided by the user at runtime, and substituted in the prompt. Output Schema {output_schema} This is the schema of the expected output, and is compiled based on the output element. For more information on how the output schema is compiled for the prompt, check out output element compilation . Prompt Primitives @prompt_primitive_name These are pre-constructed prompts that are useful for common tasks. E.g., some primitives may contain information that helps the LLM understand the output schema better. To see the full list of prompt primitives, check out guardrails/constants.xml . <rail version= \"0.1\" > <prompt> <!-- (1)! --> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} <!-- (2)! --> @xml_prefix_prompt <!-- (3)! --> {{output_schema}} <!-- (4)! --> @json_suffix_prompt <!-- (5)! --> </prompt> </rail> The prompt contains high level task information. The variable {{document}} is provided by the user at runtime. @xml_prefix_prompt is a prompt primitive provided by guardrails. It is equivalent to typing the following lines in the prompt: Given below is XML that describes the information to extract from this document and the tags to extract it into. {output_schema} is the output schema and contains information about , which is compiled based on the output element. @json_suffix_prompt is a prompt primitive provided by guardrails. It is equivalent to typing the following lines in the prompt: ONLY return a valid JSON object (no other text is necessary). The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. If you are unsure anywhere, enter `None`. JSON Output:","title":"Prompt Element"},{"location":"rail/prompt/#prompt-element","text":"The <prompt></prompt> element contains the high level instructions sent to the LLM, that describe the high level task.","title":"Prompt Element"},{"location":"rail/prompt/#components-of-a-prompt","text":"In addition to the high level task description, the prompt also contains the following: Component Syntax Description Variables {{variable_name}} These are provided by the user at runtime, and substituted in the prompt. Output Schema {output_schema} This is the schema of the expected output, and is compiled based on the output element. For more information on how the output schema is compiled for the prompt, check out output element compilation . Prompt Primitives @prompt_primitive_name These are pre-constructed prompts that are useful for common tasks. E.g., some primitives may contain information that helps the LLM understand the output schema better. To see the full list of prompt primitives, check out guardrails/constants.xml . <rail version= \"0.1\" > <prompt> <!-- (1)! --> Given the following document, answer the following questions. If the answer doesn't exist in the document, enter 'None'. {document} <!-- (2)! --> @xml_prefix_prompt <!-- (3)! --> {{output_schema}} <!-- (4)! --> @json_suffix_prompt <!-- (5)! --> </prompt> </rail> The prompt contains high level task information. The variable {{document}} is provided by the user at runtime. @xml_prefix_prompt is a prompt primitive provided by guardrails. It is equivalent to typing the following lines in the prompt: Given below is XML that describes the information to extract from this document and the tags to extract it into. {output_schema} is the output schema and contains information about , which is compiled based on the output element. @json_suffix_prompt is a prompt primitive provided by guardrails. It is equivalent to typing the following lines in the prompt: ONLY return a valid JSON object (no other text is necessary). The JSON MUST conform to the XML format, including any types and format requests e.g. requests for lists, objects and specific types. Be correct and concise. If you are unsure anywhere, enter `None`. JSON Output:","title":"\ud83d\udcda Components of a Prompt"}]}